#!/usr/bin/env bash
# Sandbox Wrapper Script
# P1-006: Container Sandboxing for AI Agent Code Execution
#
# This script provides a secure sandbox environment for executing untrusted
# code generated by AI agents. It uses Docker containers with resource limits,
# network isolation, and security constraints.
#
# Usage:
#   ./sandbox-wrapper.sh <language> <code_file> [options]
#
# Examples:
#   ./sandbox-wrapper.sh python /tmp/agent-code.py
#   ./sandbox-wrapper.sh bash /tmp/agent-script.sh --timeout 30
#   ./sandbox-wrapper.sh node /tmp/agent-app.js --memory 512m

set -euo pipefail

# Configuration
SANDBOX_NETWORK="${SANDBOX_NETWORK:-none}"
SANDBOX_TIMEOUT="${SANDBOX_TIMEOUT:-60}"  # seconds
SANDBOX_MEMORY="${SANDBOX_MEMORY:-256m}"
SANDBOX_CPU="${SANDBOX_CPU:-0.5}"
SANDBOX_TMP_DIR="${SANDBOX_TMP_DIR:-/tmp/sandbox}"
SANDBOX_LOG_DIR="${SANDBOX_LOG_DIR:-/var/log/sandbox}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $*" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

# Help text
show_help() {
    cat << EOF
Sandbox Wrapper - Secure Code Execution Environment

Usage: $0 <language> <code_file> [options]

Languages:
  python      - Python 3.x
  bash        - Bash shell scripts
  node        - Node.js JavaScript
  rust        - Rust (compile and run)
  go          - Go (compile and run)

Options:
  --timeout <seconds>     - Execution timeout (default: 60)
  --memory <size>         - Memory limit (default: 256m)
  --cpu <cores>           - CPU limit (default: 0.5)
  --network <mode>        - Network mode: none|bridge (default: none)
  --workdir <path>        - Working directory inside container
  --env <KEY=VALUE>       - Environment variable (can be repeated)
  --volume <host:container> - Mount volume (use with caution)
  --readonly              - Mount code as read-only
  --user <uid:gid>        - Run as specific user (default: nobody)
  --help                  - Show this help message

Examples:
  # Run Python code with 30s timeout
  $0 python script.py --timeout 30

  # Run with custom memory and CPU limits
  $0 node app.js --memory 512m --cpu 1.0

  # Run with environment variables
  $0 python train.py --env MODEL_PATH=/models --env BATCH_SIZE=32

Security Features:
  - Network isolation (no network access by default)
  - Resource limits (CPU, memory, timeout)
  - Read-only root filesystem
  - Runs as non-root user
  - No privilege escalation
  - Limited system capabilities
  - Temporary filesystem for writes

EOF
}

# Parse arguments
parse_args() {
    if [[ $# -lt 2 ]]; then
        log_error "Missing required arguments"
        show_help
        exit 1
    fi

    LANGUAGE="$1"
    CODE_FILE="$2"
    shift 2

    # Validate code file exists
    if [[ ! -f "$CODE_FILE" ]]; then
        log_error "Code file not found: $CODE_FILE"
        exit 1
    fi

    # Parse options
    ENV_VARS=()
    VOLUMES=()
    READONLY_MODE="false"
    USER_ID="65534:65534"  # nobody:nogroup
    WORKDIR="/workspace"

    while [[ $# -gt 0 ]]; do
        case $1 in
            --timeout)
                SANDBOX_TIMEOUT="$2"
                shift 2
                ;;
            --memory)
                SANDBOX_MEMORY="$2"
                shift 2
                ;;
            --cpu)
                SANDBOX_CPU="$2"
                shift 2
                ;;
            --network)
                SANDBOX_NETWORK="$2"
                shift 2
                ;;
            --workdir)
                WORKDIR="$2"
                shift 2
                ;;
            --env)
                ENV_VARS+=("$2")
                shift 2
                ;;
            --volume)
                VOLUMES+=("$2")
                shift 2
                ;;
            --readonly)
                READONLY_MODE="true"
                shift
                ;;
            --user)
                USER_ID="$2"
                shift 2
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# Get Docker image for language
get_docker_image() {
    case "$LANGUAGE" in
        python)
            echo "python:3.11-slim"
            ;;
        bash)
            echo "bash:5.2-alpine"
            ;;
        node)
            echo "node:20-alpine"
            ;;
        rust)
            echo "rust:1.75-slim"
            ;;
        go)
            echo "golang:1.21-alpine"
            ;;
        *)
            log_error "Unsupported language: $LANGUAGE"
            exit 1
            ;;
    esac
}

# Build Docker run command
build_docker_command() {
    local image="$1"
    local code_file="$2"
    local code_basename
    code_basename=$(basename "$code_file")

    # Base command
    local cmd=(
        docker run
        --rm
        --network "$SANDBOX_NETWORK"
        --memory "$SANDBOX_MEMORY"
        --cpus "$SANDBOX_CPU"
        --user "$USER_ID"
        --read-only
        --cap-drop ALL
        --security-opt no-new-privileges
        --tmpfs /tmp:rw,noexec,nosuid,size=64m
        --workdir "$WORKDIR"
    )

    # Add timeout
    cmd+=(--stop-timeout "$SANDBOX_TIMEOUT")

    # Add environment variables
    for env in "${ENV_VARS[@]}"; do
        cmd+=(--env "$env")
    done

    # Add code file volume
    if [[ "$READONLY_MODE" == "true" ]]; then
        cmd+=(--volume "$code_file:$WORKDIR/$code_basename:ro")
    else
        cmd+=(--volume "$code_file:$WORKDIR/$code_basename:rw")
    fi

    # Add additional volumes
    for vol in "${VOLUMES[@]}"; do
        cmd+=(--volume "$vol")
    done

    # Add image
    cmd+=("$image")

    # Add execution command based on language
    case "$LANGUAGE" in
        python)
            cmd+=(python "$WORKDIR/$code_basename")
            ;;
        bash)
            cmd+=(bash "$WORKDIR/$code_basename")
            ;;
        node)
            cmd+=(node "$WORKDIR/$code_basename")
            ;;
        rust)
            # Rust requires compilation first
            cmd+=(sh -c "rustc $WORKDIR/$code_basename -o /tmp/app && /tmp/app")
            ;;
        go)
            # Go requires compilation first
            cmd+=(sh -c "go run $WORKDIR/$code_basename")
            ;;
    esac

    echo "${cmd[@]}"
}

# Execute code in sandbox
execute_sandbox() {
    local image
    image=$(get_docker_image)

    log_info "Starting sandbox execution"
    log_info "Language: $LANGUAGE"
    log_info "Code file: $CODE_FILE"
    log_info "Image: $image"
    log_info "Timeout: ${SANDBOX_TIMEOUT}s"
    log_info "Memory limit: $SANDBOX_MEMORY"
    log_info "CPU limit: $SANDBOX_CPU"
    log_info "Network: $SANDBOX_NETWORK"

    # Build command
    local docker_cmd
    docker_cmd=$(build_docker_command "$image" "$CODE_FILE")

    # Create log directory if it doesn't exist
    mkdir -p "$SANDBOX_LOG_DIR"

    # Execute with timeout
    local start_time
    start_time=$(date +%s)

    log_info "Executing code..."

    # Run with timeout command
    if timeout "${SANDBOX_TIMEOUT}s" bash -c "$docker_cmd"; then
        local exit_code=$?
        local end_time
        end_time=$(date +%s)
        local duration=$((end_time - start_time))

        log_info "Execution completed successfully in ${duration}s"
        return "$exit_code"
    else
        local exit_code=$?
        local end_time
        end_time=$(date +%s)
        local duration=$((end_time - start_time))

        if [[ $exit_code -eq 124 ]]; then
            log_error "Execution timed out after ${SANDBOX_TIMEOUT}s"
        else
            log_error "Execution failed with exit code: $exit_code (duration: ${duration}s)"
        fi
        return "$exit_code"
    fi
}

# Main execution
main() {
    parse_args "$@"
    execute_sandbox
}

# Run main function
main "$@"
